theory StackToAssembly
imports StackLanguage AssemblyLanguage Iterate
begin

primrec instruction_conv :: "stack_instruction \<Rightarrow> assembly list" where
  "instruction_conv Add = [CAssm {A} (Reg M), CAssm {D} (Reg M), AAssm 0, CAssm {A, M} (Decr M), CAssm {M} DPlusM, AAssm 0]"
| "instruction_conv Sub = [CAssm {A} (Reg M), CAssm {D} (Reg M), AAssm 0, CAssm {A, M} (Decr M), CAssm {M} MMinusD, AAssm 0]"
| "instruction_conv Neg = [CAssm {A} (Reg M), CAssm {M} (NegR M), AAssm 0]"
| "instruction_conv Eq = undefined"
| "instruction_conv Gt = undefined"
| "instruction_conv Lt = undefined"
| "instruction_conv And = [CAssm {A} (Reg M), CAssm {D} (Reg M), AAssm 0, CAssm {A, M} (Decr M), CAssm {M} DAndM, AAssm 0]"
| "instruction_conv Or = [CAssm {A} (Reg M), CAssm {D} (Reg M), AAssm 0, CAssm {A, M} (Decr M), CAssm {M} DOrM, AAssm 0]"
| "instruction_conv Not = [CAssm {A} (Reg M), CAssm {D} (NotR M), AAssm 0]"

definition program_convert :: "stack_program \<Rightarrow> assembly_program" where
  "program_convert \<Pi> = map_option concat o map_option (map instruction_conv) o \<Pi>"

primrec stack_to_mem :: "int list \<Rightarrow> (int \<Rightarrow> int) \<Rightarrow> int \<Rightarrow> int" where
  "stack_to_mem [] \<mu> k = (if k = 0 then 0 else \<mu> k)"
| "stack_to_mem (i # is) \<mu> k = (
    if k = 0 then 1 + int (length is) 
    else if k > 0 \<and> k = 1 + int (length is) then i 
    else stack_to_mem is \<mu> k)" 

primrec state_convert :: "stack_state \<Rightarrow> assembly_state set" where
  "state_convert (\<sigma>, \<pi>) = {(stack_to_mem \<sigma> \<mu>, Some 0, d, concat (map instruction_conv \<pi>)) | d \<mu>. True }"

(* conversion correctness *)

lemma [simp]: "dom (program_convert \<Pi>) = dom \<Pi>"
  by (auto simp add: program_convert_def)

lemma [simp]: "(stack_to_mem (i1 # \<sigma>) \<mu>)(1 + int (length \<sigma>) := i2) = stack_to_mem (i2 # \<sigma>) \<mu>"
  by auto

lemma eval_stack_conv [simp]: "eval_stack \<Pi> \<Sigma>\<^sub>S = Some \<Sigma>\<^sub>S' \<Longrightarrow> \<Sigma>\<^sub>A \<in> state_convert \<Sigma>\<^sub>S \<Longrightarrow> 
    \<exists>\<Sigma>\<^sub>A'. \<Sigma>\<^sub>A' \<in> state_convert \<Sigma>\<^sub>S' \<and> iterate (eval_assembly (program_convert \<Pi>)) \<Sigma>\<^sub>A \<Sigma>\<^sub>A'"
  proof (induction \<Pi> \<Sigma>\<^sub>S rule: eval_stack.induct)
  case (1 \<Pi> i1 i2 \<sigma> \<pi>)
    thus ?case by simp
  next case 2
    thus ?case by simp
  next case (3 \<Pi> i1 \<sigma> \<pi>)
    let ?\<pi>' = "concat (map instruction_conv \<pi>)"
    from 3 obtain d \<mu> where M: "\<Sigma>\<^sub>A = (stack_to_mem (i1 # \<sigma>) \<mu>, Some 0, d, 
      [CAssm {A} (Reg M), CAssm {M} (NegR M), AAssm 0] @ ?\<pi>')" by fastforce
    from 3 have S: "\<Sigma>\<^sub>S' = ((-i1) # \<sigma>, \<pi>)" by simp
    let ?\<mu> = "stack_to_mem (i1 # \<sigma>) \<mu>"
    let ?\<Sigma>\<^sub>A\<^sub>1 = "(?\<mu>, Some (?\<mu> 0), d, [CAssm {M} (NegR M), AAssm 0] @ ?\<pi>')"
    let ?\<Sigma>\<^sub>A\<^sub>2 = "(?\<mu>(?\<mu> 0 := - ?\<mu> (?\<mu> 0)), Some (?\<mu> 0), d, [AAssm 0] @ ?\<pi>')"
    let ?\<Sigma>\<^sub>A\<^sub>3 = "(?\<mu>(?\<mu> 0 := - ?\<mu> (?\<mu> 0)), Some 0, d, ?\<pi>')"
    from M have step1: "eval_assembly (program_convert \<Pi>) \<Sigma>\<^sub>A = Some ?\<Sigma>\<^sub>A\<^sub>1" by simp
    have step2: "eval_assembly (program_convert \<Pi>) ?\<Sigma>\<^sub>A\<^sub>1 = Some ?\<Sigma>\<^sub>A\<^sub>2" by simp
    have "eval_assembly (program_convert \<Pi>) ?\<Sigma>\<^sub>A\<^sub>2 = Some ?\<Sigma>\<^sub>A\<^sub>3" by simp
    with iter_two iter_prestep step1 step2 have X:
      "iterate (eval_assembly (program_convert \<Pi>)) \<Sigma>\<^sub>A ?\<Sigma>\<^sub>A\<^sub>3" by fast
    have "?\<Sigma>\<^sub>A\<^sub>3 \<in> state_convert ((-i1) # \<sigma>, \<pi>)" by auto
    with X S M show ?case by metis
  next case 4
    thus ?case by simp
  next case 5
    thus ?case by simp
  next case 6
    thus ?case by simp
  next case 7
    thus ?case by simp
  next case 8
    thus ?case by simp
  next case 9
    thus ?case by simp

  (* autogenerated cases where "eval_stack \<Pi> \<Sigma>\<^sub>S = None" *)
  next case "10_1" thus ?case by simp
  next case "10_2" thus ?case by simp
  next case "10_3" thus ?case by simp
  next case "10_4" thus ?case by simp
  next case "10_5" thus ?case by simp
  next case "10_6" thus ?case by simp
  next case "10_7" thus ?case by simp
  next case "10_8" thus ?case by simp
  next case "10_9" thus ?case by simp
  next case "10_10" thus ?case by simp
  next case "10_11" thus ?case by simp
  next case "10_12" thus ?case by simp
  next case "10_13" thus ?case by simp
  next case "10_14" thus ?case by simp
  next case "10_15" thus ?case by simp
  next case "10_16" thus ?case by simp
  next case "10_17" thus ?case by simp
  next case "10_18" thus ?case by simp
  next case "10_19" thus ?case by simp
  next case "10_20" thus ?case by simp
  next case "10_21" thus ?case by simp
  next case "10_22" thus ?case by simp
  next case "10_23" thus ?case by simp
  next case "10_24" thus ?case by simp
  qed

theorem stack_to_assembly_correct [simp]: "iterate (eval_stack \<Pi>) \<Sigma>\<^sub>S \<Sigma>\<^sub>S' \<Longrightarrow> 
  \<Sigma>\<^sub>A \<in> state_convert \<Sigma>\<^sub>S \<Longrightarrow> 
    \<exists>\<Sigma>\<^sub>A'. \<Sigma>\<^sub>A' \<in> state_convert \<Sigma>\<^sub>S' \<and> iterate (eval_assembly (program_convert \<Pi>)) \<Sigma>\<^sub>A \<Sigma>\<^sub>A'"
  proof (induction "eval_stack \<Pi>" \<Sigma>\<^sub>S \<Sigma>\<^sub>S' arbitrary: \<Sigma>\<^sub>A rule: iterate.induct)
  case iter_refl
    thus ?case by fastforce
  next case (iter_step \<Sigma>\<^sub>S \<Sigma>\<^sub>S' \<Sigma>\<^sub>S'')
    then obtain \<Sigma>\<^sub>A' where S: "\<Sigma>\<^sub>A' \<in> state_convert \<Sigma>\<^sub>S' \<and> 
      iterate (eval_assembly (program_convert \<Pi>)) \<Sigma>\<^sub>A \<Sigma>\<^sub>A'" by blast
    with iter_step eval_stack_conv obtain \<Sigma>\<^sub>A'' where
        "\<Sigma>\<^sub>A'' \<in> state_convert \<Sigma>\<^sub>S'' \<and> iterate (eval_assembly (program_convert \<Pi>)) \<Sigma>\<^sub>A' \<Sigma>\<^sub>A''" 
      by blast
    with S have "\<Sigma>\<^sub>A'' \<in> state_convert \<Sigma>\<^sub>S'' \<and> iterate (eval_assembly (program_convert \<Pi>)) \<Sigma>\<^sub>A \<Sigma>\<^sub>A''" 
      by fastforce
    thus ?case by blast
  qed

end